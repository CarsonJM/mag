include { CAT_CAT               } from '../../modules/nf-core/cat/cat/main'
include { MAG_TO_SAMPLESHEET    } from '../../modules/local/mag_to_samplesheet'
include { MAG_MERGE_SAMPLESHEET } from '../../modules/local/mag_merge_samplesheet'

workflow SAMPLESHEET_CREATION {
    take:
        short_reads //channel: [val(meta), path(fastq_1), path(fastq_2)]
        assemblies  //channel: [val(meta), path(fasta)]
    main:
        ch_versions = Channel.empty()

        // combine assemblies by sample/group if multiple assembly methods were used
        ch_assemblies = assemblies
            .map {
                meta, fasta ->
                    def meta_new = meta.subMap('id')
                [ meta_new, fasta ]
            }
            .groupTuple()

        //
        // MODULE: Combine all assemblies from a sample into one FastA file
        //
        ch_combined_assemblies = CAT_CAT ( ch_assemblies ).file_out
        ch_versions = ch_versions.mix( CAT_CAT.out.versions )

        // if no coassembly, join FastQ and FastA by ID
        if ( !params.coassemble_group ){
            ch_combined_assemblies_remap = ch_combined_assemblies
                .map {
                    meta, fasta ->
                        def id          = meta.id

                        return [ id, fasta ]
                }
            short_reads
                .map {
                    meta, fastq ->
                        def id          = meta.id
                        def group       = meta.group
                        def single_end  = meta.single_end

                        return [ id, group, single_end, fastq ]
                }.join ( ch_combined_assemblies_remap )
                .map {
                    id, group, single_end, fastq, fasta ->
                        def reads   = fastq instanceof List ? fastq.flatten() : [ fastq ]
                        def meta    = [:]

                        meta.id         = id
                        meta.group      = group
                        meta.single_end = single_end
                        meta.fastq_1    = reads[0] ? reads[0] : ''
                        meta.fastq_2    = reads[1] && !meta.single_end ? reads[1] : ''
                        meta.fasta      = fasta ? fasta : ''

                        return meta
                }
                .set { ch_mag_metadata }
        } else {
            // if coassembly was used, join FastQ and FastA by group
            ch_combined_assemblies_remap = ch_combined_assemblies
                .map {
                    meta, fasta ->
                        def group = meta.id.split('-')

                            return [ group[1], fasta ]
                }
            short_reads
                .map {
                    meta, fastq ->
                        def id          = meta.id
                        def group       = meta.group
                        def single_end  = meta.single_end

                            return [ group, id, single_end, fastq ]
                }
                .join ( ch_combined_assemblies_remap )
                .map {
                    id, group, single_end, fastq, fasta ->
                        def reads   = fastq instanceof List ? fastq.flatten() : [ fastq ]
                        def meta    = [:]

                        meta.id         = id
                        meta.group      = group
                        meta.single_end = single_end
                        meta.fastq_1    = reads[0] ? reads[0] : ''
                        meta.fastq_2    = reads[1] && !meta.single_end ? reads[1] : ''
                        meta.fasta      = fasta ? fasta : ''

                        return meta
                }
                .set { ch_mag_metadata }
        }

        //
        // MODULE: Stage FastQ/FastA files generated by nf-core/mag together and auto-create a samplesheet
        //
        MAG_TO_SAMPLESHEET (
            ch_mag_metadata,
            params.nf_core_pipeline ?: ''
        )

        //
        // MODULE: Create a merged samplesheet across all samples for the pipeline
        //
        MAG_MERGE_SAMPLESHEET (
            MAG_TO_SAMPLESHEET.out.samplesheet.collect{it[1]}
        )
        ch_versions = ch_versions.mix( MAG_MERGE_SAMPLESHEET.out.versions )

    emit:
        samplesheet         = ch_assemblies
        versions            = ch_versions       // channel: [ versions.yml ]
}
